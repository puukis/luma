module @std.buffer

// Standard Buffer module for Luma
// Binary data manipulation and byte arrays

// Buffer class for handling binary data
open class Buffer {
  def init(size_or_data) {
    if (size_or_data == nil) {
      this.data = []
      this.capacity = 0
    } else if (size_or_data is Number) {
      // Initialize with given size
      this.data = []
      this.capacity = size_or_data
      i = 0
      until (i >= size_or_data) {
        push(this.data, 0)
        i = i + 1
      }
    } else if (size_or_data is List) {
      // Initialize from list of bytes
      this.data = size_or_data.slice(0)  // copy
      this.capacity = len(this.data)
    } else if (size_or_data is String) {
      // Initialize from string (convert to bytes)
      this.data = this._string_to_bytes(size_or_data)
      this.capacity = len(this.data)
    } else {
      this.data = []
      this.capacity = 0
    }
  }

  // Get buffer length
  def length() {
    return len(this.data)
  }

  // Get buffer capacity
  def cap() {
    return this.capacity
  }

  // Check if buffer is empty
  def is_empty() {
    return len(this.data) == 0
  }

  // Clear the buffer
  def clear() {
    this.data = []
  }

  // Get byte at index
  def get(index) {
    if (index < 0 or index >= len(this.data)) {
      return nil
    }
    return this.data[index]
  }

  // Set byte at index
  def set(index, value) {
    if (index < 0 or index >= len(this.data)) {
      return false
    }
    this.data[index] = this._to_byte(value)
    return true
  }

  // Append a single byte
  def append_byte(byte) {
    push(this.data, this._to_byte(byte))
    if (len(this.data) > this.capacity) {
      this.capacity = len(this.data)
    }
  }

  // Append multiple bytes from list
  def append_bytes(bytes) {
    i = 0
    until (i >= len(bytes)) {
      this.append_byte(bytes[i])
      i = i + 1
    }
  }

  // Append bytes from another buffer
  def append_buffer(other) {
    this.append_bytes(other.data)
  }

  // Insert byte at index
  def insert(index, byte) {
    if (index < 0) {
      index = 0
    }
    if (index >= len(this.data)) {
      this.append_byte(byte)
      return
    }

    // Shift elements to make room
    new_data = []
    i = 0
    until (i >= index) {
      push(new_data, this.data[i])
      i = i + 1
    }
    push(new_data, this._to_byte(byte))
    until (i >= len(this.data)) {
      push(new_data, this.data[i])
      i = i + 1
    }
    this.data = new_data
  }

  // Remove byte at index
  def remove(index) {
    if (index < 0 or index >= len(this.data)) {
      return nil
    }

    removed = this.data[index]
    new_data = []
    i = 0
    until (i >= len(this.data)) {
      if (i != index) {
        push(new_data, this.data[i])
      }
      i = i + 1
    }
    this.data = new_data
    return removed
  }

  // Get sub-buffer from start to end
  def slice(start, end) {
    if (start == nil) {
      start = 0
    }
    if (end == nil) {
      end = len(this.data)
    }

    if (start < 0) {
      start = 0
    }
    if (end > len(this.data)) {
      end = len(this.data)
    }
    if (start >= end) {
      return Buffer([])
    }

    result = []
    i = start
    until (i >= end) {
      push(result, this.data[i])
      i = i + 1
    }
    return Buffer(result)
  }

  // Copy data from another buffer
  def copy_from(other, offset, length) {
    if (offset == nil) {
      offset = 0
    }
    if (length == nil) {
      length = len(other.data)
    }

    end = offset + length
    if (end > len(other.data)) {
      end = len(other.data)
    }

    this.data = []
    i = offset
    until (i >= end) {
      push(this.data, other.data[i])
      i = i + 1
    }
  }

  // Convert to string
  def to_string() {
    return this._bytes_to_string(this.data)
  }

  // Convert to hex string
  def to_hex() {
    use @std.encoding as encoding
    return encoding.hex_encode(this.to_string())
  }

  // Convert to base64 string
  def to_base64() {
    use @std.encoding as encoding
    return encoding.base64_encode(this.to_string())
  }

  // Fill buffer with value
  def fill(value, start, end) {
    if (start == nil) {
      start = 0
    }
    if (end == nil) {
      end = len(this.data)
    }

    if (start < 0) {
      start = 0
    }
    if (end > len(this.data)) {
      end = len(this.data)
    }

    i = start
    until (i >= end) {
      this.data[i] = this._to_byte(value)
      i = i + 1
    }
  }

  // Read unsigned 8-bit integer
  def read_uint8(offset) {
    if (offset < 0 or offset >= len(this.data)) {
      return nil
    }
    return this.data[offset]
  }

  // Read unsigned 16-bit integer (big-endian)
  def read_uint16_be(offset) {
    if (offset < 0 or offset + 1 >= len(this.data)) {
      return nil
    }
    return (this.data[offset] << 8) | this.data[offset + 1]
  }

  // Read unsigned 16-bit integer (little-endian)
  def read_uint16_le(offset) {
    if (offset < 0 or offset + 1 >= len(this.data)) {
      return nil
    }
    return this.data[offset] | (this.data[offset + 1] << 8)
  }

  // Read unsigned 32-bit integer (big-endian)
  def read_uint32_be(offset) {
    if (offset < 0 or offset + 3 >= len(this.data)) {
      return nil
    }
    return (this.data[offset] << 24) |
           (this.data[offset + 1] << 16) |
           (this.data[offset + 2] << 8) |
           this.data[offset + 3]
  }

  // Read unsigned 32-bit integer (little-endian)
  def read_uint32_le(offset) {
    if (offset < 0 or offset + 3 >= len(this.data)) {
      return nil
    }
    return this.data[offset] |
           (this.data[offset + 1] << 8) |
           (this.data[offset + 2] << 16) |
           (this.data[offset + 3] << 24)
  }

  // Write unsigned 8-bit integer
  def write_uint8(offset, value) {
    if (offset < 0 or offset >= len(this.data)) {
      return false
    }
    this.data[offset] = this._to_byte(value)
    return true
  }

  // Write unsigned 16-bit integer (big-endian)
  def write_uint16_be(offset, value) {
    if (offset < 0 or offset + 1 >= len(this.data)) {
      return false
    }
    this.data[offset] = (value >> 8) & 255
    this.data[offset + 1] = value & 255
    return true
  }

  // Write unsigned 16-bit integer (little-endian)
  def write_uint16_le(offset, value) {
    if (offset < 0 or offset + 1 >= len(this.data)) {
      return false
    }
    this.data[offset] = value & 255
    this.data[offset + 1] = (value >> 8) & 255
    return true
  }

  // Write unsigned 32-bit integer (big-endian)
  def write_uint32_be(offset, value) {
    if (offset < 0 or offset + 3 >= len(this.data)) {
      return false
    }
    this.data[offset] = (value >> 24) & 255
    this.data[offset + 1] = (value >> 16) & 255
    this.data[offset + 2] = (value >> 8) & 255
    this.data[offset + 3] = value & 255
    return true
  }

  // Write unsigned 32-bit integer (little-endian)
  def write_uint32_le(offset, value) {
    if (offset < 0 or offset + 3 >= len(this.data)) {
      return false
    }
    this.data[offset] = value & 255
    this.data[offset + 1] = (value >> 8) & 255
    this.data[offset + 2] = (value >> 16) & 255
    this.data[offset + 3] = (value >> 24) & 255
    return true
  }

  // Helper: Convert string to bytes
  def _string_to_bytes(str) {
    result = []
    i = 0
    until (i >= len(str)) {
      // For now, just use character codes
      // In a real implementation, this would handle UTF-8 properly
      char_code = this._char_code_at(str, i)
      push(result, this._to_byte(char_code))
      i = i + 1
    }
    return result
  }

  // Helper: Convert bytes to string
  def _bytes_to_string(bytes) {
    result = ""
    i = 0
    until (i >= len(bytes)) {
      result = result + this._char_from_code(bytes[i])
      i = i + 1
    }
    return result
  }

  // Helper: Ensure byte range
  def _to_byte(value) {
    if (value < 0) {
      return 0
    }
    if (value > 255) {
      return 255
    }
    return value
  }

  // Helper: Get character code (simplified)
  def _char_code_at(str, index) {
    // This is a placeholder - real implementation would need backend support
    // For now, return basic ASCII values
    if (index >= len(str)) {
      return 0
    }
    // Simple ASCII mapping for basic characters
    char = str[index]
    if (char >= " " and char <= "~") {
      return 32 + (char - " ")  // Basic ASCII range
    }
    return 63  // '?' for unknown chars
  }

  // Helper: Get character from code (simplified)
  def _char_from_code(code) {
    // This is a placeholder - real implementation would need backend support
    if (code < 32 or code > 126) {
      return "?"
    }
    // Simple reverse mapping
    return "" + (code - 32 + " ")  // This won't work perfectly but is a placeholder
  }
}

// Utility functions

// Create buffer from string
open def from_string(str) {
  return Buffer(str)
}

// Create buffer from hex string
open def from_hex(hex_str) {
  use @std.encoding as encoding
  decoded = encoding.hex_decode(hex_str)
  return Buffer(decoded)
}

// Create buffer from base64 string
open def from_base64(b64_str) {
  use @std.encoding as encoding
  decoded = encoding.base64_decode(b64_str)
  return Buffer(decoded)
}

// Concatenate multiple buffers
open def concat(buffers) {
  result = Buffer([])
  i = 0
  until (i >= len(buffers)) {
    result.append_buffer(buffers[i])
    i = i + 1
  }
  return result
}

// Compare two buffers
open def compare(a, b) {
  min_len = len(a.data)
  if (len(b.data) < min_len) {
    min_len = len(b.data)
  }

  i = 0
  until (i >= min_len) {
    if (a.data[i] != b.data[i]) {
      if (a.data[i] < b.data[i]) {
        return -1
      } else {
        return 1
      }
    }
    i = i + 1
  }

  if (len(a.data) == len(b.data)) {
    return 0
  }
  if (len(a.data) < len(b.data)) {
    return -1
  } else {
    return 1
  }
}

// Check if two buffers are equal
open def equals(a, b) {
  return compare(a, b) == 0
}

// Export Buffer class constructor
open def create_buffer(size_or_data) {
  return Buffer.new(size_or_data)
}